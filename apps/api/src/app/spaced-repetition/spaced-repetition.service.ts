import { Injectable } from "@nestjs/common";
import { SpacedRepetitionSetsService } from "./spaced-repetition-sets.service";
import { PrismaService } from "../providers/database/prisma/prisma.service";
import { CardWithIdValidator } from "../sets/validator/cardWithId.validator";

@Injectable()
export class SpacedRepetitionService {
  constructor(
    private spacedRepetitionSetsService: SpacedRepetitionSetsService,
    private prisma: PrismaService
  ) {}

  /**
   * Implementation of the SM2 spaced repetition algorithm
   *
   * @param quality An integer from 0-3 inclusive that indicates how easily the information was remembered, with 0 being most difficult
   * @param previousRepetitions The number of repetitions that the card has been reviewed prior to this review
   * @param previousEaseFactor A float that is generated by the algorithm, used to determine number of days between review. Equal to 2.5 if field left empty, indicating this is the first review day
   * @param interval A number generated by the algorithm, indicates the number of days to wait between reviews. Equal to 0 if field left empty, indicating this is the first review day
   *
   * @remarks Adapted from https://github.com/thyagoluciano/sm2
   */
  sm2(quality: number, previousRepetitions: number, previousEaseFactor?: number, interval?: number): {
    interval: number,
    repetitions: number,
    easeFactor: number
  } {
    let repetitions = previousRepetitions ?? 0;
    let easeFactor = previousEaseFactor ?? 2.5;

    // max 6 choices down to 4
    if (quality === 3) {
      quality = 5;
    } else if (quality === 2) {
      quality = 3;
    } else if (quality === 1) {
      quality = 2;
    } else {
      quality = 0;
    }

    if (quality >= 3) {
      if (previousRepetitions === 0) {
        interval = 1;
      } else if (previousRepetitions === 1) {
        interval = 6;
      } else {
        interval = Math.ceil(interval * previousEaseFactor);
      }

      repetitions++;
      easeFactor = previousEaseFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality ) * 0.02));
    } else {
      repetitions = 0;
      interval = 1;
    }

    if (easeFactor < 1.3) {
      easeFactor = 1.3;
    }

    return {
      interval,
      repetitions,
      easeFactor: +easeFactor.toFixed(3)
    };
  }

  async addNewSpacedRepetitionCards(setId: string, newCards: CardWithIdValidator[]) {
    const spacedRepetitionSets = await this.spacedRepetitionSetsService.spacedRepetitionSets({
      where: {
        setId
      }
    });

    const queries = [];

    for (const spacedRepetitionSet of spacedRepetitionSets) {
      queries.push(this.prisma.spacedRepetitionSet.update({
        where: {
          id: spacedRepetitionSet.id
        },
        data: {
          spacedRepetitionCards: {
            createMany: {
              data: newCards.map((c) => {
                return {
                  cardId: c.id
                };
              })
            }
          }
        }
      }));
    }

    // this transaction will finish after the user has already received a response
    // so no point in doing anything if this fails
    try {
      await this.prisma.$transaction(queries);
    } catch (e) {
      return;
    }
  }
}
